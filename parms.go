// Copyright 2016 Martin Angers. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package httpparms provides helper functions and types to load the
// content of an HTTP request into a Go struct. It supports loading the
// query string parameters, the form-encoded body and the JSON-encoded
// body. If the struct implements the "Validator" interface, it also
// validates the values.
//
// It supports various form decoders and JSON unmarshalers. Common
// such packages that can be used for forms are:
//   - github.com/go-playground/form (requires the FormDecoderAdapter)
//   - github.com/gorilla/schema
//
// Common packages that can be used for JSON are:
//   - encoding/json in the standard library
//   - pquerna/ffjson/ffjson
//
// The package also provides support to extract parameter names that failed
// validation so that a useful error message can be given to the caller.
package httpparms

import (
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"net/url"
	"sort"
)

// FormDecoderAdapter is an adapter for form decoder functions that
// take an url.Values type instead of a map[string][]string.
func FormDecoderAdapter(fn func(v interface{}, vals url.Values) error) func(interface{}, map[string][]string) error {
	return func(v interface{}, vals map[string][]string) error {
		return fn(v, url.Values(vals))
	}
}

// Parser decodes request parameters into a struct and validates
// the values if the struct implements Validator.
//
// If the Form, JSON and ParametersExtractor values used by the Parser are
// safe for concurrent use, then the Parser is also safe for concurrent
// use. This is typically the case when using the recommended decoders.
type Parser struct {
	// Form is the function to use to decode form values from a map.
	// If it is nil, form decoding will fail with an error.
	Form func(v interface{}, vals map[string][]string) error

	// JSON is the function to use to unmarshal JSON from a
	// slice of bytes. If it is nil, json.Unmarshal from the
	// standard library is used.
	JSON func(data []byte, v interface{}) error

	// ParametersExtractor is the function that can extract parameter names
	// from an error. The error may be generated by the JSON unmarshaler,
	// the form decoder, or may be any custom error returned by the
	// parameters validation.  The function doesn't have to handle all
	// cases, it can return nil for errors it doesn't know about.
	// If it is nil, no parameters are extracted.
	ParametersExtractor func(err error) []string

	_ struct{} // prevent unkeyed literals
}

// Validator defines the method required for a type to validate itself.
type Validator interface {
	Validate() error
}

func (p *Parser) schemaDecode(dst interface{}, vals url.Values) error {
	if p.Form == nil {
		return errors.New("httpparms: no form decoder")
	}
	return p.Form(dst, vals)
}

// ParseQueryForm parses the Form parameters of r into dst. The parameters
// may be provided in the query string or in the form-encoded body.
// The dst value must be a pointer to a struct that contains fields
// matching the form parameters, possibly using `schema` struct tags.
// If dst is a Validator, Validate is called and its error returned.
func (p *Parser) ParseQueryForm(r *http.Request, dst interface{}) error {
	if err := r.ParseForm(); err != nil {
		return err
	}

	if err := p.schemaDecode(dst, r.Form); err != nil {
		return err
	}

	if val, ok := dst.(Validator); ok {
		return val.Validate()
	}
	return nil
}

// ParseJSON parses the body of the request as JSON and unmarshals it into
// dst. If dst is a Validator, Validate is called and its error returned.
// The body is parsed as JSON regardless of the content-type of the request.
func (p *Parser) ParseJSON(r *http.Request, dst interface{}) error {
	b, err := io.ReadAll(r.Body)
	if err != nil {
		return err
	}
	if len(b) > 0 {
		fn := p.JSON
		if fn == nil {
			fn = json.Unmarshal
		}
		if err := fn(b, dst); err != nil {
			return err
		}
	}

	if val, ok := dst.(Validator); ok {
		return val.Validate()
	}
	return nil
}

// ParseQueryJSON parses the query values, and the body of the request as JSON
// and stores the values in dst. If dst is a Validator, Validate is called and
// its error returned. The body is parsed as JSON regardless of the
// content-type of the request.
func (p *Parser) ParseQueryJSON(r *http.Request, dst interface{}) error {
	vals := r.URL.Query()
	if err := p.schemaDecode(dst, vals); err != nil {
		return err
	}
	return p.ParseJSON(r, dst)
}

// ParseQuery parses the query values and stores the values in dst. If
// dst is a Validator, Validate is called and its error returned.
func (p *Parser) ParseQuery(r *http.Request, dst interface{}) error {
	vals := r.URL.Query()
	if err := p.schemaDecode(dst, vals); err != nil {
		return err
	}
	if val, ok := dst.(Validator); ok {
		return val.Validate()
	}
	return nil
}

// ParametersFromErr returns the list of parameter names that triggered
// the error. This can be used to return a helpful error message to the
// caller. The parameter names are deduplicated and sorted. It tries
// to extract parameter names in the following order:
//
//   - If errors.As finds an error that implements a "Parameters() []string"
//     method, it uses those values.
//   - If errors.As finds an error that implements a "Parameter() string"
//     method, it uses this value.
//   - If the parser has a non-nil ParametersExtractor, it calls it and uses
//     those values.
func (p *Parser) ParametersFromErr(err error) []string {
	if err == nil {
		return nil
	}

	var pms parameters
	if errors.As(err, &pms) {
		return dedupeAndSort(pms.Parameters())
	}
	var pm parameter
	if errors.As(err, &pm) {
		if nm := pm.Parameter(); nm != "" {
			return []string{nm}
		}
		return nil
	}
	if p.ParametersExtractor != nil {
		return dedupeAndSort(p.ParametersExtractor(err))
	}
	return nil
}

type parameters interface {
	error
	Parameters() []string
}

type parameter interface {
	error
	Parameter() string
}

func dedupeAndSort(vals []string) []string {
	if len(vals) == 0 {
		return nil
	}

	set := make(map[string]bool, len(vals))
	for _, v := range vals {
		set[v] = true
	}
	ret := make([]string, 0, len(set))
	for k := range set {
		ret = append(ret, k)
	}
	sort.Strings(ret)
	return ret
}
