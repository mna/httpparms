// Copyright 2016 Martin Angers. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package httpparms provides helper functions and types to load the
// content of an HTTP request into a Go struct. It supports loading the
// query string parameters, the form-encoded body and the JSON-encoded
// body. If the struct implements the "Validator" interface, it also
// validates the values.
//
// It supports various form decoders and JSON unmarshalers. Common
// such packages that can be used for forms are:
//     - github.com/go-playground/form (requires the FormDecoderAdapter)
//     - github.com/gorilla/schema
//
// Common packages that can be used for JSON are:
//     - encoding/json in the standard library
//     - pquerna/ffjson/ffjson
//
// The package also provides support to extract parameter names that failed
// validation so that a useful error message can be given to the caller.
//
package httpparms

import (
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"sort"
)

// FormDecoderAdapter is an adapter for form decoder functions that
// take an url.Values type instead of a map[string][]string.
func FormDecoderAdapter(fn func(v interface{}, vals url.Values) error) func(interface{}, map[string][]string) error {
	return func(v interface{}, vals map[string][]string) error {
		return fn(v, url.Values(vals))
	}
}

// Parser decodes request parameters into a struct and validates
// the values if the struct implements Validator.
//
// If the Form, JSON and ParametersExtractor values used by the Parser are
// safe for concurrent use, then the Parser is also safe for concurrent
// use. This is typically the case when using the recommended decoders.
type Parser struct {
	// Form is the function to use to decode form values from a map.
	// If it is nil, form decoding will fail with an error.
	Form func(v interface{}, vals map[string][]string) error

	// JSON is the function to use to unmarshal JSON from a
	// slice of bytes. If it is nil, json.Unmarshal from the
	// standard library is used.
	JSON func(data []byte, v interface{}) error

	// ParametersExtractor is the function that can extract parameter names
	// from an error. The error may be generated by the JSON unmarshaler,
	// the form decoder, or may be any custom error returned by the
	// parameters validation.  The function doesn't have to handle all
	// cases, it can return nil for errors it doesn't know about.
	// If it is nil, no parameters are extracted.
	ParametersExtractor func(err error) []string

	_ struct{} // prevent unkeyed literals
}

// Validator defines the method required for a type to validate itself.
type Validator interface {
	Validate() error
}

func (p *Parser) schemaDecode(dst interface{}, vals url.Values) error {
	if p.Form == nil {
		return errors.New("httpparms: no form decoder")
	}
	return p.Form(dst, vals)
}

// ParseQueryForm parses the Form parameters of r into dst. The parameters
// may be provided in the query string or in the form-encoded body.
// The dst value must be a pointer to a struct that contains fields
// matching the form parameters, possibly using `schema` struct tags.
// If dst is a Validator, Validate is called and its error returned.
func (p *Parser) ParseQueryForm(r *http.Request, dst interface{}) error {
	if err := r.ParseForm(); err != nil {
		return err
	}

	if err := p.schemaDecode(dst, r.Form); err != nil {
		return err
	}

	if val, ok := dst.(Validator); ok {
		return val.Validate()
	}
	return nil
}

// ParseJSON parses the body of the request as JSON and unmarshals it into
// dst. If dst is a Validator, Validate is called and its error returned.
// The body is parsed as JSON regardless of the content-type of the request.
func (p *Parser) ParseJSON(r *http.Request, dst interface{}) error {
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return err
	}
	if len(b) > 0 {
		fn := p.JSON
		if fn == nil {
			fn = json.Unmarshal
		}
		if err := fn(b, dst); err != nil {
			return err
		}
	}

	if val, ok := dst.(Validator); ok {
		return val.Validate()
	}
	return nil
}

// ParseQueryJSON parses the query values and the body of the request as JSON
// and stores the values in dst. If dst is a Validator, Validate is called and
// its error returned. The body is parsed as JSON regardless of the
// content-type of the request.
func (p *Parser) ParseQueryJSON(r *http.Request, dst interface{}) error {
	vals := r.URL.Query()
	if err := p.schemaDecode(dst, vals); err != nil {
		return err
	}
	return p.ParseJSON(r, dst)
}

// ParseQuery parses the query values and stores the values in dst. If
// dst is a Validator, Validate is called and its error returned.
func (p *Parser) ParseQuery(r *http.Request, dst interface{}) error {
	vals := r.URL.Query()
	if err := p.schemaDecode(dst, vals); err != nil {
		return err
	}
	if val, ok := dst.(Validator); ok {
		return val.Validate()
	}
	return nil
}

// ParametersFromErr returns the list of parameter names that triggered
// the error. This can be used to return a helpful error message to the
// caller. The parameter names are deduplicated and sorted. It tries
// to extract parameter names in the following order:
//
//     - If the error implements a "Cause() error" method, it calls it and
//       uses the returned error for the other steps.
//     - If the error implements a "Parameter() string" method, it uses this
//       value.
//     - If the error implements a "Parameters() []string" method, it uses
//       those values.
//     - If the parser has a non-nil ParametersExtractor, it calls it and uses
//       those values.
//     - If there are no parameter names found at this point and the error
//       implements the "WrappedErrors() []error" method, it calls it and
//       applies the first 4 steps on each error, cumulating the return values.
//
func (p *Parser) ParametersFromErr(err error) []string {
	if err == nil {
		return nil
	}

	if nms := p.parametersFromSingleErr(err, nil); len(nms) > 0 {
		return dedupeAndSort(nms)
	}
	if we, ok := err.(interface {
		WrappedErrors() []error
	}); ok {
		var nms []string
		for _, e := range we.WrappedErrors() {
			nms = p.parametersFromSingleErr(e, nms)
		}
		return dedupeAndSort(nms)
	}
	return nil
}

func dedupeAndSort(vals []string) []string {
	set := make(map[string]bool, len(vals))
	for _, v := range vals {
		set[v] = true
	}
	ret := make([]string, 0, len(set))
	for k := range set {
		ret = append(ret, k)
	}
	sort.Strings(ret)
	return ret
}

func (p *Parser) parametersFromSingleErr(err error, cumul []string) []string {
	if ce, ok := err.(interface {
		Cause() error
	}); ok {
		err = ce.Cause()
	}
	if pe, ok := err.(interface {
		Parameter() string
	}); ok {
		if nm := pe.Parameter(); nm != "" {
			cumul = append(cumul, nm)
		}
		return cumul
	}
	if pe, ok := err.(interface {
		Parameters() []string
	}); ok {
		if nms := pe.Parameters(); len(nms) > 0 {
			cumul = append(cumul, nms...)
		}
		return cumul
	}
	if p.ParametersExtractor != nil {
		if nms := p.ParametersExtractor(err); len(nms) > 0 {
			cumul = append(cumul, nms...)
		}
		return cumul
	}
	return cumul
}
